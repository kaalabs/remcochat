/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/v2/actions": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Execute one action (v2)
         * @description Execute a single typed action.
         *
         *     Authentication (required): **one** of:
         *     - `Authorization: Bearer <token>`
         *     - `X-API-Key: <key>`
         *
         *     Correlation:
         *     - `X-Request-Id` header is preferred.
         *     - Body `requestId` is echoed in responses.
         *     - If both are present they MUST match, otherwise `400 request_id_mismatch`.
         *
         *     Idempotency (replay-safe retries):
         *     - Use `Idempotency-Key` header (preferred) and/or body `idempotencyKey`.
         *     - Header wins; if both present and differ → `400 invalid_idempotency_key`.
         *     - If the same key is in-flight → `409 idempotency_in_progress` with retry guidance.
         *
         *     v2 error model:
         *     - 2xx responses always have `ok:true`.
         *     - Non-2xx responses always have `ok:false` and use the canonical error envelope.
         */
        post: {
            parameters: {
                query?: never;
                header?: {
                    /** @description Correlation id. If body `requestId` is present, it MUST match this value. */
                    "X-Request-Id"?: components["parameters"]["XRequestId"];
                    /** @description Idempotency key for replay-safe retries. Header wins over body `idempotencyKey`. */
                    "Idempotency-Key"?: components["parameters"]["IdempotencyKey"];
                };
                path?: never;
                cookie?: never;
            };
            requestBody: {
                content: {
                    "application/json": components["schemas"]["ActionRequestV2"];
                };
            };
            responses: {
                /** @description Action executed successfully. */
                200: {
                    headers: {
                        "X-Request-Id": components["headers"]["XRequestId"];
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ActionSuccessResponseV2"];
                    };
                };
                /** @description Partial success for actions.batch when continueOnError=true. */
                207: {
                    headers: {
                        "X-Request-Id": components["headers"]["XRequestId"];
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ActionsBatchSuccess"];
                    };
                };
                400: components["responses"]["BadRequest"];
                401: components["responses"]["Unauthorized"];
                404: components["responses"]["NotFound"];
                409: components["responses"]["Conflict"];
                424: components["responses"]["FailedDependency"];
                429: components["responses"]["TooManyRequests"];
                500: components["responses"]["InternalServerError"];
                502: components["responses"]["BadGateway"];
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/events/stream": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Normalized Hue event stream (SSE) v2
         * @description Server-Sent Events (SSE) stream of normalized Hue change events.
         *
         *     Auth: required.
         *
         *     Resume:
         *     - The gateway emits `id: <eventCursor>` on every event.
         *     - Clients may send `Last-Event-ID: <eventCursor>` on reconnect.
         *     - If the gateway cannot replay, it emits a `needs_resync` event.
         *
         *     Inventory coherence:
         *     - Every event JSON payload includes `revision` (inventory revision).
         *     - Clients SHOULD refresh `inventory.snapshot` when `revision` changes.
         *
         *     Event payload schema (JSON in `data:` frames) is documented in `components/schemas/SseEvent`.
         */
        get: {
            parameters: {
                query?: never;
                header?: {
                    /** @description Correlation id. If body `requestId` is present, it MUST match this value. */
                    "X-Request-Id"?: components["parameters"]["XRequestId"];
                    /** @description SSE resume cursor (event cursor). */
                    "Last-Event-ID"?: components["parameters"]["LastEventId"];
                };
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description SSE stream (text/event-stream). */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "text/event-stream": string;
                    };
                };
                401: components["responses"]["Unauthorized"];
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        ErrorEnvelopeV2: {
            /** @description Echoed requestId (if known). */
            requestId?: string | null;
            /** @description Echoed action name (if known). */
            action?: string | null;
            /** @constant */
            ok: false;
            error: components["schemas"]["ActionError"];
        };
        ActionError: {
            /**
             * @description Machine-readable error code.
             *
             *     v2 code registry (seed; extensible):
             *     - invalid_json (400, not retryable)
             *     - invalid_request (400, not retryable)
             *     - invalid_action (400, not retryable)
             *     - unknown_action (400, not retryable)
             *     - invalid_args (400, not retryable)
             *     - request_id_mismatch (400, not retryable)
             *     - invalid_idempotency_key (400, not retryable)
             *     - unauthorized (401, not retryable)
             *     - not_found (404, not retryable)
             *     - ambiguous_name (409, not retryable)
             *     - no_confident_match (409, not retryable)
             *     - link_button_not_pressed (409, retryable after user action)
             *     - idempotency_in_progress (409, retryable after wait)
             *     - idempotency_key_reuse_mismatch (409, not retryable)
             *     - bridge_unreachable (424, retryable with backoff)
             *     - rate_limited (429, retryable after wait)
             *     - bridge_rate_limited (429, retryable after wait)
             *     - bridge_error (502, maybe retryable if safe/idempotent)
             *     - internal_error (500, maybe retryable)
             */
            code: string;
            message: string;
            details: {
                [key: string]: unknown;
            };
        };
        Warning: {
            code: string;
            message: string;
            details?: {
                [key: string]: unknown;
            };
        };
        MatchOptions: {
            /**
             * @description Name matching mode.
             *
             *     Notes:
             *     - `normalized` applies: `" ".join(value.strip().lower().split())` before matching.
             *     - `fuzzy` returns a confidence score in [0,1]; higher is better.
             * @enum {string}
             */
            mode?: "exact" | "case_insensitive" | "normalized" | "fuzzy";
            /** @description Minimum confidence required to auto-select a match. */
            minConfidence?: number;
            /** @description Minimum confidence gap between best and runner-up required to auto-select. */
            minGap?: number;
            /** @description Max candidates to return in `ambiguous_name` / `no_confident_match` errors. */
            maxCandidates?: number;
        };
        /**
         * @description Per-field tolerance overrides.
         *
         *     Defaults (unless overridden):
         *     - `light.*`: brightness ±5, colorTempK ±200K
         *     - `grouped_light` / `room.set` / `zone.set`: brightness ±25, colorTempK ±800K
         *     - `xy`: verify off by default unless explicitly requested
         */
        VerifyTolerances: {
            /** @description Absolute tolerance for brightness (percent points). */
            brightness?: number;
            /** @description Absolute tolerance for color temperature (Kelvin). */
            colorTempK?: number;
        };
        VerifyOptions: {
            /**
             * @default none
             * @enum {string}
             */
            mode: "none" | "poll" | "sse" | "poll_then_sse";
            /** @default 2000 */
            timeoutMs: number;
            /** @default 150 */
            pollIntervalMs: number;
            tolerances?: components["schemas"]["VerifyTolerances"];
        };
        XYColor: {
            x: number;
            y: number;
        };
        /**
         * @description Light state (normalized for tool calling).
         *
         *     - brightness: 0–100 (%)
         *     - colorTempK: Kelvin
         *     - xy: CIE xy color
         */
        LightState: {
            on?: boolean;
            brightness?: number;
            colorTempK?: number;
            xy?: components["schemas"]["XYColor"];
        };
        Candidate: {
            rid: string;
            name?: string;
            confidence: number;
        };
        ResolveByNameMatched: {
            rid: string;
            rtype: string;
            name?: string;
        };
        ClipV2Result: {
            status: number;
            /** @description Hue Bridge response body (usually JSON). */
            body: unknown;
        };
        ActionRequestV2: components["schemas"]["BridgeSetHostRequest"] | components["schemas"]["BridgePairRequest"] | components["schemas"]["ClipV2Request"] | components["schemas"]["ResolveByNameRequest"] | components["schemas"]["LightSetRequest"] | components["schemas"]["GroupedLightSetRequest"] | components["schemas"]["SceneActivateRequest"] | components["schemas"]["RoomSetRequest"] | components["schemas"]["ZoneSetRequest"] | components["schemas"]["InventorySnapshotRequest"] | components["schemas"]["ActionsBatchRequest"];
        ActionSuccessResponseV2: components["schemas"]["BridgeSetHostSuccess"] | components["schemas"]["BridgePairSuccess"] | components["schemas"]["ClipV2Success"] | components["schemas"]["ResolveByNameSuccess"] | components["schemas"]["LightSetSuccess"] | components["schemas"]["GroupedLightSetSuccess"] | components["schemas"]["SceneActivateSuccess"] | components["schemas"]["RoomSetSuccess"] | components["schemas"]["ZoneSetSuccess"] | components["schemas"]["InventorySnapshotSuccess"] | components["schemas"]["ActionsBatchSuccess"];
        BridgeSetHostArgs: {
            /** @description Hue Bridge IP/hostname on the LAN (no scheme/path). */
            bridgeHost: string;
        };
        BridgeSetHostRequest: {
            requestId?: string;
            idempotencyKey?: string;
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            action: "bridge.set_host";
            args: components["schemas"]["BridgeSetHostArgs"];
        };
        BridgeSetHostResult: {
            bridgeHost: string;
            stored: boolean;
        };
        BridgeSetHostSuccess: {
            requestId?: string;
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            action: "bridge.set_host";
            /** @constant */
            ok: true;
            result: components["schemas"]["BridgeSetHostResult"];
        };
        BridgePairArgs: {
            /** @description Bridge registration device type (free-form string). */
            devicetype?: string;
        };
        BridgePairRequest: {
            requestId?: string;
            idempotencyKey?: string;
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            action: "bridge.pair";
            args: components["schemas"]["BridgePairArgs"];
        };
        BridgePairResult: {
            applicationKey: string;
            stored: boolean;
        };
        BridgePairSuccess: {
            requestId?: string;
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            action: "bridge.pair";
            /** @constant */
            ok: true;
            result: components["schemas"]["BridgePairResult"];
        };
        ClipV2RequestArgs: {
            /** @enum {string} */
            method: "GET" | "POST" | "PUT" | "DELETE" | "HEAD" | "OPTIONS";
            /** @description Must start with `/clip/v2/` and must not contain scheme/host. */
            path: string;
            /** @description Optional JSON body (object or array) for POST/PUT requests. */
            body?: unknown;
            /** @description Best-effort retry hint. The gateway may still refuse retries for unsafe methods. */
            retry?: boolean;
        };
        ClipV2Request: {
            requestId?: string;
            idempotencyKey?: string;
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            action: "clipv2.request";
            args: components["schemas"]["ClipV2RequestArgs"];
        };
        ClipV2Success: {
            requestId?: string;
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            action: "clipv2.request";
            /** @constant */
            ok: true;
            result: components["schemas"]["ClipV2Result"];
        };
        ResolveByNameArgs: {
            rtype: string;
            name: string;
            match?: components["schemas"]["MatchOptions"];
        };
        ResolveByNameRequest: {
            requestId?: string;
            idempotencyKey?: string;
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            action: "resolve.by_name";
            args: components["schemas"]["ResolveByNameArgs"];
        };
        ResolveByNameResult: {
            matched: components["schemas"]["ResolveByNameMatched"];
            confidence: number;
        };
        ResolveByNameSuccess: {
            requestId?: string;
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            action: "resolve.by_name";
            /** @constant */
            ok: true;
            result: components["schemas"]["ResolveByNameResult"];
        };
        LightSetArgs: {
            rid?: string;
            name?: string;
            match?: components["schemas"]["MatchOptions"];
            state: components["schemas"]["LightState"];
            verify?: components["schemas"]["VerifyOptions"];
        };
        LightSetRequest: {
            requestId?: string;
            idempotencyKey?: string;
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            action: "light.set";
            args: components["schemas"]["LightSetArgs"];
        };
        LightSetSuccess: {
            requestId?: string;
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            action: "light.set";
            /** @constant */
            ok: true;
            result: components["schemas"]["SetStateResult"];
        };
        GroupedLightSetArgs: {
            rid?: string;
            name?: string;
            match?: components["schemas"]["MatchOptions"];
            state: components["schemas"]["LightState"];
            verify?: components["schemas"]["VerifyOptions"];
        };
        GroupedLightSetRequest: {
            requestId?: string;
            idempotencyKey?: string;
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            action: "grouped_light.set";
            args: components["schemas"]["GroupedLightSetArgs"];
        };
        GroupedLightSetSuccess: {
            requestId?: string;
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            action: "grouped_light.set";
            /** @constant */
            ok: true;
            result: components["schemas"]["SetStateResult"];
        };
        SceneActivateArgs: {
            rid?: string;
            name?: string;
            match?: components["schemas"]["MatchOptions"];
            verify?: components["schemas"]["VerifyOptions"];
        };
        SceneActivateRequest: {
            requestId?: string;
            idempotencyKey?: string;
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            action: "scene.activate";
            args: components["schemas"]["SceneActivateArgs"];
        };
        SceneActivateResult: {
            status: number;
            /** @description Hue Bridge response body (usually JSON). */
            body: unknown;
        };
        SceneActivateSuccess: {
            requestId?: string;
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            action: "scene.activate";
            /** @constant */
            ok: true;
            result: components["schemas"]["SceneActivateResult"];
        };
        SetStateResult: {
            requested: components["schemas"]["LightState"];
            applied: components["schemas"]["LightState"];
            observed?: components["schemas"]["LightState"];
            verified: boolean;
            warnings: components["schemas"]["Warning"][];
        };
        RoomSetArgs: {
            roomRid?: string;
            roomName?: string;
            match?: components["schemas"]["MatchOptions"];
            state: components["schemas"]["LightState"];
            verify?: components["schemas"]["VerifyOptions"];
        };
        RoomSetRequest: {
            requestId?: string;
            idempotencyKey?: string;
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            action: "room.set";
            args: components["schemas"]["RoomSetArgs"];
        };
        RoomSetResult: components["schemas"]["SetStateResult"] & {
            roomRid: string;
            groupedLightRid: string;
        };
        RoomSetSuccess: {
            requestId?: string;
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            action: "room.set";
            /** @constant */
            ok: true;
            result: components["schemas"]["RoomSetResult"];
        };
        ZoneImpact: {
            affectedRooms?: {
                rid: string;
                name?: string;
            }[];
            affectedLightsCount?: number;
        };
        ZoneSetArgs: {
            zoneRid?: string;
            zoneName?: string;
            /** @default false */
            dryRun: boolean;
            match?: components["schemas"]["MatchOptions"];
            state?: components["schemas"]["LightState"];
            verify?: components["schemas"]["VerifyOptions"];
        };
        ZoneSetRequest: {
            requestId?: string;
            idempotencyKey?: string;
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            action: "zone.set";
            args: components["schemas"]["ZoneSetArgs"];
        };
        ZoneSetResultDryRun: {
            /** @constant */
            dryRun: true;
            zoneRid: string;
            groupedLightRid: string;
            impact: components["schemas"]["ZoneImpact"];
        };
        ZoneSetResultApplied: components["schemas"]["SetStateResult"] & {
            /** @constant */
            dryRun: false;
            zoneRid: string;
            groupedLightRid: string;
            impact?: components["schemas"]["ZoneImpact"];
        };
        ZoneSetResult: components["schemas"]["ZoneSetResultDryRun"] | components["schemas"]["ZoneSetResultApplied"];
        ZoneSetSuccess: {
            requestId?: string;
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            action: "zone.set";
            /** @constant */
            ok: true;
            result: components["schemas"]["ZoneSetResult"];
        };
        InventorySnapshotArgs: {
            ifRevision?: number;
        };
        InventorySnapshotRequest: {
            requestId?: string;
            idempotencyKey?: string;
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            action: "inventory.snapshot";
            args: components["schemas"]["InventorySnapshotArgs"];
        };
        InventorySnapshotResultNotModified: {
            /** @constant */
            notModified: true;
            revision: number;
        };
        InventoryRoom: {
            rid: string;
            name: string;
            groupedLightRid: string;
        };
        InventoryZone: {
            rid: string;
            name: string;
            groupedLightRid: string;
            roomRids?: string[];
        };
        InventoryLight: {
            rid: string;
            name: string;
            ownerDeviceRid: string;
            roomRid?: string;
        };
        InventorySnapshotResultFull: {
            /** @constant */
            notModified?: false;
            bridgeId: string;
            /** Format: date-time */
            generatedAt: string;
            revision: number;
            stale: boolean;
            staleReason?: ("not_configured" | "bridge_unreachable" | "sse_disconnected" | "cache_too_old" | "unknown") | null;
            rooms: components["schemas"]["InventoryRoom"][];
            zones: components["schemas"]["InventoryZone"][];
            lights: components["schemas"]["InventoryLight"][];
        };
        InventorySnapshotResult: components["schemas"]["InventorySnapshotResultNotModified"] | components["schemas"]["InventorySnapshotResultFull"];
        InventorySnapshotSuccess: {
            requestId?: string;
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            action: "inventory.snapshot";
            /** @constant */
            ok: true;
            result: components["schemas"]["InventorySnapshotResult"];
        };
        BatchStepRequest: components["schemas"]["BridgeSetHostRequest"] | components["schemas"]["BridgePairRequest"] | components["schemas"]["ClipV2Request"] | components["schemas"]["ResolveByNameRequest"] | components["schemas"]["LightSetRequest"] | components["schemas"]["GroupedLightSetRequest"] | components["schemas"]["SceneActivateRequest"] | components["schemas"]["RoomSetRequest"] | components["schemas"]["ZoneSetRequest"] | components["schemas"]["InventorySnapshotRequest"];
        ActionsBatchArgs: {
            /**
             * @description If true, continue executing steps and return 207 with per-step results.
             * @default false
             */
            continueOnError: boolean;
            actions: components["schemas"]["BatchStepRequest"][];
        };
        ActionsBatchRequest: {
            requestId?: string;
            idempotencyKey?: string;
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            action: "actions.batch";
            args: components["schemas"]["ActionsBatchArgs"];
        };
        BatchStepResult: {
            index: number;
            action: string;
            requestId?: string;
            idempotencyKey?: string;
            ok: boolean;
            status: number;
            /** @description Step result (when ok=true). Shape depends on action. */
            result?: unknown;
            error?: components["schemas"]["ActionError"];
        };
        ActionsBatchResult: {
            continueOnError: boolean;
            steps: components["schemas"]["BatchStepResult"][];
        };
        ActionsBatchSuccess: {
            requestId?: string;
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            action: "actions.batch";
            /** @constant */
            ok: true;
            result: components["schemas"]["ActionsBatchResult"];
        };
        /** @description Resource reference. `null` is used for events that are not tied to a single Hue resource (e.g. `needs_resync`). */
        SseResourceRef: null | {
            rid: string;
            rtype: string;
        };
        SseEvent: {
            /** Format: date-time */
            ts: string;
            /** @description Event type (example: `resource.updated`, `resource.deleted`, `needs_resync`). */
            type: string;
            resource: components["schemas"]["SseResourceRef"];
            /** @description Inventory revision (refresh `inventory.snapshot` when it changes). */
            revision: number;
            /** @description Optional duplication of the SSE `id:` cursor. */
            eventId?: number;
            /** @description Event-specific payload; for lights/grouped_lights, include a useful delta when possible. */
            data?: unknown;
        };
    };
    responses: {
        /** @description Bad request. */
        BadRequest: {
            headers: {
                "X-Request-Id": components["headers"]["XRequestId"];
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["ErrorEnvelopeV2"];
            };
        };
        /** @description Unauthorized. */
        Unauthorized: {
            headers: {
                "X-Request-Id": components["headers"]["XRequestId"];
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["ErrorEnvelopeV2"];
            };
        };
        /** @description Not found. */
        NotFound: {
            headers: {
                "X-Request-Id": components["headers"]["XRequestId"];
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["ErrorEnvelopeV2"];
            };
        };
        /** @description Conflict. */
        Conflict: {
            headers: {
                "X-Request-Id": components["headers"]["XRequestId"];
                "Retry-After": components["headers"]["RetryAfter"];
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["ErrorEnvelopeV2"];
            };
        };
        /** @description Bridge unreachable. */
        FailedDependency: {
            headers: {
                "X-Request-Id": components["headers"]["XRequestId"];
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["ErrorEnvelopeV2"];
            };
        };
        /** @description Rate limited. */
        TooManyRequests: {
            headers: {
                "X-Request-Id": components["headers"]["XRequestId"];
                "Retry-After": components["headers"]["RetryAfter"];
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["ErrorEnvelopeV2"];
            };
        };
        /** @description Internal server error. */
        InternalServerError: {
            headers: {
                "X-Request-Id": components["headers"]["XRequestId"];
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["ErrorEnvelopeV2"];
            };
        };
        /** @description Bridge returned an error. */
        BadGateway: {
            headers: {
                "X-Request-Id": components["headers"]["XRequestId"];
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["ErrorEnvelopeV2"];
            };
        };
    };
    parameters: {
        /** @description Correlation id. If body `requestId` is present, it MUST match this value. */
        XRequestId: string;
        /** @description Idempotency key for replay-safe retries. Header wins over body `idempotencyKey`. */
        IdempotencyKey: string;
        /** @description SSE resume cursor (event cursor). */
        LastEventId: string;
    };
    requestBodies: never;
    headers: {
        /** @description Correlation id echoed by the gateway when provided. */
        XRequestId: string;
        /** @description Seconds to wait before retrying. */
        RetryAfter: number;
    };
    pathItems: never;
}
export type $defs = Record<string, never>;
export type operations = Record<string, never>;
